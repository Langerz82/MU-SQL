#ifndef _MU_GOFUNCTIONS_H_
#define _MU_GOFUNCTIONS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "StdAfx.h"

void gObjSkillUseProcTime500(LPGameObject &lpObj);
void MonsterAndMsgProc();
void MoveMonsterProc();
void gObjSetState();
void gObjInit(); // constructor ?
void gObjEnd(); // destructor ?
void gObjClearViewportOfMine(LPGameObject &lpObj);
void gObjClearViewport(LPGameObject &lpObj);
void gObjCloseSet(LPGameObject &lpObj, int Flag);
void gObjCharTradeClear(LPGameObject &lpObj);
void gObjCharZeroSet(int aIndex);
int gObjGetSocket(SOCKET socket);
int gObjGetHWIDUseCount(LPSTR HWID);
void gObjSetTradeOption(LPGameObject &lpObj, int option);
bool IsDuelEnable(int aIndex);
bool IsOnDuel(int aIndex1, int aIndex2);
void gObjSetDuelOption(LPGameObject &lpObj, int option);
int GetMapMoveLevel(LPGameObject &lpObj, int mapnumber, int max_over);
void DbItemSetInByte(LPGameObject &lpObj, struct SDHP_DBCHAR_INFORESULT* lpMsg, bool* bAllItemExist);
void gObjSetBP(int aIndex);
bool gObjSetCharacter(unsigned char* lpdata, int aIndex);
int gObjCanItemTouch(LPGameObject &lpObj, int type);
void gObjMagicTextSave(LPGameObject &lpObj);
void ItemIsBufExOption(unsigned char* buf, class CItem* lpItem);
void gObjStatTextSave(LPGameObject &lpObj);
void gObjItemTextSave(LPGameObject &lpObj);
void gObjWarehouseTextSave(LPGameObject &lpObj);
void gObjAuthorityCodeSet(LPGameObject &lpObj);
int gObjSetPosMonster(LPGameObject &lpObj, int PosTableNum);
int gObjSetMonster(LPGameObject &lpObj, int MonsterClass);
int gObjGetSocket(SOCKET socket);
int GetMapMoveLevel(LPGameObject &lpObj, int mapnumber, int max_over);
void ItemIsBufExOption(unsigned char* buf, class CItem* lpItem);
short gObjAddSearch(SOCKET aSocket, char* ip);
short gObjAdd(SOCKET aSocket, char* ip, int aIndex);
short gObjMonsterRecall(int iMapNumber);
short gObjAddMonster(int iMapNumber);
short gObjAddCallMon();
void gObjUserKill(int aIndex);
void gObjAllLogOut();
void gObjAllDisconnect();
void gObjTradeSave(LPGameObject &lpObj, int index);
void gObjBillRequest(LPGameObject &lpObj);
short gObjMemFree(int index);
int gObjGameClose(int aIndex);
short gObjDel(int index);
short gObjSometimeClose(int index);
int gObjIsGamePlaing(LPGameObject &lpObj);
int gObjIsConnectedGP(LPGameObject &lpObj, char* CharName);
int gObjIsConnectedGP(int aIndex);
int gObjIsConnected(LPGameObject &lpObj, int dbnumber);
int gObjIsConnected(int aIndex);
bool gObjIsAccountValid(LPGameObject &lpObj, char* account);
int gObjIsConnected(LPGameObject &lpObj);
int gObjIsConnectedEx(int aIndex);
int gObjIsAccontConnect(LPGameObject &lpObj, char* accountid);
int gObjPasswordCheck(LPGameObject &lpObj, char* szInPassword);
int gObjCheckXYMapTile(LPGameObject &lpObj, int iDbgName);
int gObjSetAccountLogin(LPGameObject &lpObj, char* szId, int aUserNumber, int aDBNumber, char* Password);
int gObjGetUserNumber(int aIndex);
int gObjGetNumber(LPGameObject &lpObj, int& UN, int& DBN);
LPSTR gObjGetAccountId(int aIndex);
int gObjGetIndex(char* szId);
int gObjUserIdConnectCheck(char* szId, int index);
unsigned char GetPathPacketDirPos(int px, int py);
int gObjCalDistance(LPGameObject &lpObj1, CGameObject* lpObj2);
int gObjPositionCheck(LPGameObject &lpObj);
int gObjCheckTileArea(LPGameObject &lpObj, int x, int y, int dis);
int ExtentCheck(int x, int y, int w, int h);
BOOL CheckOutOfInventory(LPGameObject &lpObj, int sy, int height);	//-> 1.01.00
BOOL InventoryExtentCheck(int x, int y, int w, int h);		//-> 1.01.00
BOOL CheckOutOfWarehouse(LPGameObject &lpObj, int sy, int height);	//-> 1.01.00
BOOL WarehouseExtentCheck(int x, int y, int w, int h);		//-> 1.01.00
void gObjSetInventory1Pointer(LPGameObject &lpObj);
void gObjSetInventory2Pointer(LPGameObject &lpObj);
void gObjAddMsgSend(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode);
void gObjAddMsgSendDelay(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode);
void gObjAddMsgSendDelayInSpecificQPos(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode, int iQPosition);
void gObjAddAttackProcMsgSendDelay(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode, int SubCode2);
void gObjMsgProc(LPGameObject &lpObj);
void gObjStateProc(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode);
void gObjStateAttackProc(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode, int SubCode2);
int gObjBackSpring(LPGameObject &lpObj, CGameObject* lpTargetObj);
int BackSpringCheck(int& x, int& y, int& dir, unsigned char map);
int gObjBackSpring2(LPGameObject &lpObj, CGameObject* lpTargetObj, int count);
bool gObjLevelUp(LPGameObject &lpObj, UINT64 addexp, int iMonsterType, const char * szEventType);
int gObjLevelUpPointAdd(unsigned char type, CGameObject* lpObj, int aIndex);
void gObjGiveItemSearch(LPGameObject &lpObj, int maxlevel);
void gObjGiveItemWarehouseSearch(LPGameObject &lpObj, int maxlevel);
int gObjGuildMasterCapacityTest(LPGameObject &lpObj);
void gObjNextExpCal(LPGameObject &lpObj);
int retResistance(LPGameObject &lpObj, int Resistance_Type);
int retCalcSkillResistance(LPGameObject &lpTargetObj, int isDouble);
int gObjAttackQ(LPGameObject &lpObj);
void gObjPlayerKiller(LPGameObject &lpObj, CGameObject* lpTargetObj, int MSBDamage);
void gObjUserDie(LPGameObject &lpObj, CGameObject* lpTargetObj);
void gObjInterfaceTimeCheck(LPGameObject &lpObj);
void gObjPkDownTimeCheck(LPGameObject &lpObj, int TargetLevel);
int gObjAngelSprite(LPGameObject &lpObj);
int gObjDemonSprite(LPGameObject &lpObj);
int gObjSatanSprite(LPGameObject &lpObj);
int gObjSafeGuardSprite(LPGameObject &lpObj);
int gObjFindInventoryEquipment(int aIndex);
int gObjSetInventoryEquipment(LPGameObject &lpObj, unsigned char btPos);
int gObjInventoryEquipment(LPGameObject &lpObj);
int gObjWingSprite(LPGameObject &lpObj);
int gObjUniriaSprite(LPGameObject &lpObj);
void gObjSpriteDamage(LPGameObject &lpObj, int damage);
void gObjSecondDurDown(LPGameObject &lpObj);
void gObjChangeDurProc(LPGameObject &lpObj);
void gObjWingDurProc(LPGameObject &lpObj);
void gObjPenaltyDurDown(LPGameObject &lpObj, CGameObject* lpTargetObj);
void gObjWeaponDurDown(LPGameObject &lpObj, CGameObject* lpTargetObj, int type);
void gObjArmorRandomDurDown(LPGameObject &lpObj, CGameObject* lpAttackObj);
bool gObjIsSelfDefense(LPGameObject &lpObj, int aTargetIndex);
void gObjCheckSelfDefense(LPGameObject &lpObj, int aTargetIndex);
void gObjTimeCheckSelfDefense(LPGameObject &lpObj);
int gObjAttack(LPGameObject &lpObj, CGameObject* lpTargetObj, class CMagicInf* lpMagic, int magicsend, unsigned char MSBFlag, int AttackDamage, BOOL bCombo, BYTE RFAttack, BYTE byReflect, BYTE byPentagramAttack = TRUE);
void gObjMonsterExpDivision(LPGameObject &lpMonObj, CGameObject* lpObj, int AttackDamage, int MSBFlag);
void gObjMonsterExpDivisionRenewal(LPGameObject &lpMonObj, CGameObject* lpObj, int AttackDamage, int MSBFlag);
UINT64 gObjMonsterExpSingle(LPGameObject &lpObj, CGameObject* lpTargetObj, int dmg, int tot_dmg, bool& bSendExp, UINT64& nDropZen);
UINT64 gObjMonsterExpSingleRenewal(LPGameObject &lpObj, CGameObject* lpTargetObj, int dmg, int tot_dmg, bool &bSendExp);
void gObjExpParty(LPGameObject &lpObj, CGameObject* lpTargetObj, int AttackDamage, int MSBFlag);
UINT64 gObjExpPartyRenewal(int nPartyNumber, int nLastAttackUserIndex, CGameObject* lpTargetObj, int AttackDamage, int nTotalDamage, int MSBFlag);
void gObjMonsterDieLifePlus(LPGameObject &lpObj, CGameObject* lpTartObj);
void gObjLifeCheck(LPGameObject &lpTargetObj, CGameObject* lpObj, int AttackDamage, int DamageSendType, int MSBFlag, int MSBDamage, unsigned short Skill, int iShieldDamage, int iElementalDamage);
int gObjInventoryTrans(int aIndex);
int gObjInventoryCommit(int aIndex);
int gObjInventoryRollback(int aIndex);
void gObjInventoryItemSet(LPGameObject &lpObj, int itempos, unsigned char set_byte);
void gObjInventoryItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, unsigned char set_byte);
bool gObjFixInventoryPointer(int aIndex);
BYTE gObjInventoryDeleteItem(LPGameObject &lpObj, int itempos);
BYTE gObjWarehouseDeleteItem(LPGameObject &lpObj, int itempos);
BYTE gObjChaosBoxDeleteItem(LPGameObject &lpObj, int itempos);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int iSerial, int iDur);
DWORD gGetItemNumber();
void gPlusItemNumber();
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int iSerial, int iDur);
unsigned char gObjOnlyInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level);
int gObjSearchItem(LPGameObject &lpObj, int item_type, int add_dur, int nLevel);
int gObjSearchItemMinus(LPGameObject &lpObj, int pos, int m_dur);
unsigned char gObjShopBuyInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjShopBuyMuunInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjShopBuyEventInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjInventoryInsertItemTemp(LPGameObject &lpObj, class CMapItem* Item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, class CMapItem* item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjMonsterInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int op1, int op2, int op3);
unsigned char gObjInventoryRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjOnlyInventoryRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
int CheckInventoryEmptySpace(LPGameObject &lpObj, int iItemHeight, int iItemWidth);
int gObjIsItemPut(LPGameObject &lpObj, class CItem* lpItem, int pos);
unsigned char gObjWerehouseRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjMapRectCheck(unsigned char* lpMapBuf, int sx, int sy, int ex, int ey, int width, int height);
void gObjWarehouseItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, unsigned char set_byte);
void gObjWarehouseItemSet(LPGameObject &lpObj, int itempos, unsigned char set_byte);
void gObjChaosItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, unsigned char set_byte);
void gObjChaosItemSet(LPGameObject &lpObj, int itempos, unsigned char set_byte);
unsigned char gObjChaosBoxInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int source);
unsigned char gObjWarehouseInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int source);
unsigned char gObjInventoryInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int RequestCheck);
int gObjInventorySearchSerialNumber(LPGameObject &lpObj, UINT64 serial);
int gObjWarehouseSearchSerialNumber(LPGameObject &lpObj, UINT64 sirial);
unsigned char gObjInventoryMoveItem(LPGameObject &lpObj, unsigned char source, unsigned char target, int& durSsend, int& durTsend, unsigned char sFlag, unsigned char tFlag, unsigned char* siteminfo);
unsigned char gObjTradeRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
int gObjTradeItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, unsigned char set_byte);
unsigned char gObjTradeInventoryMove(LPGameObject &lpObj, unsigned char source, unsigned char target);
unsigned char gObjInventoryTradeMove(LPGameObject &lpObj, unsigned char source, unsigned char target);
unsigned char gObjTradeTradeMove(LPGameObject &lpObj, unsigned char source, unsigned char target);
void gObjTradeCancel(int aIndex);
void gObjTempInventoryItemBoxSet(unsigned char* TempMap, int itempos, int xl, int yl, unsigned char set_byte);
unsigned char gObjTempInventoryRectCheck(LPGameObject &lpObj, unsigned char* TempMap, int sx, int sy, int width, int height);
unsigned char gObjTempInventoryInsertItem(LPGameObject &lpObj, class CItem item, unsigned char* TempMap);
int TradeItemInventoryPutTest(int aIndex);
int TradeitemInventoryPut(int aIndex);
void gObjTradeOkButton(int aIndex);
unsigned char LevelSmallConvert(int level);
unsigned char LevelSmallConvert(LPGameObject &lpObj, int inventoryindex);
void gObjAttackDamageCalc(int aIndex);
void gObjMakePreviewCharSet(int aIndex);
void gObjViewportPaint(HWND hWnd);
void InitFrustrum();
void InitFrustrumEx(); // 1.01.10B GS KOR, changed values
void CreateFrustrum(int x, int y, int aIndex);
bool TestFrustrum2(int x, int y, int aIndex);
int gObjCheckViewport(LPGameObject &lpObj, int x, int y);
void gObjViewportClose(LPGameObject &lpObj);
void gObjViewportListCreate(short aIndex);
int ViewportAdd(LPGameObject &lpObj, int aAddIndex, int aType);
int ViewportAdd2(LPGameObject &lpObj, int aAddIndex, int aType);
void ViewportDel(short aIndex, int aDelIndex);
void Viewport2Del(short aIndex, int aDelIndex);
void gObjViewportAllDel(short aIndex);
void gObjViewportListDestroy(short aIndex);;
void gObjStateSetCreate(int aIndex);
void gObjSecondProc();
void gObjManaPotionFill(LPGameObject &lpObj);
void gObjRestPotionFill(LPGameObject &lpObj);
void gObjUseDrink(LPGameObject &lpObj, int level);
void gObjViewportListProtocolDestroy(LPGameObject &lpObj);
void gObjViewportListProtocolCreate(LPGameObject &lpObj);
void gObjViewportListProtocol(short aIndex);
void gObjTeleportMagicUse(LPGameObject &lpObj, unsigned char x, unsigned char y);
int gObjMoveGate(LPGameObject &lpObj, int gt);
void gObjTeleport(LPGameObject &lpObj, int map, int x, int y);
void gObjMoveDataLoadingOK(int aIndex);
class CMagicInf* gObjGetMagic(LPGameObject &lpObj, int mIndex);
class CMagicInf* gObjGetMagicSearch(LPGameObject &lpObj, unsigned short skillnumber);
int gObjMagicManaUse(LPGameObject &lpObj, class CMagicInf* lpMagic);
int gObjMagicBPUse(LPGameObject &lpObj, class CMagicInf* lpMagic);
void gObjMagicAddEnergyCheckOnOff(int flag);
int gObjMagicAdd(LPGameObject &lpObj, unsigned short aSkill, unsigned char Level);
int gObjMagicDel(LPGameObject &lpObj, unsigned short aSkill, unsigned char Level);
int gObjMagicAdd(LPGameObject &lpObj, unsigned short Type, unsigned short Index, unsigned char Level, unsigned short& SkillNumber);
int gObjWeaponMagicAdd(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMonsterMagicAdd(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMagicEnergyCheck(LPGameObject &lpObj, unsigned short aSkill);
int gObjSpecialItemLevelUp(LPGameObject &lpObj, int source, int target);
int gObjSpecialItemRepair(LPGameObject &lpObj, int source, int target);
int gObjItemLevelUp(LPGameObject &lpObj, int source, int target);
int gObjItemRandomLevelUp(LPGameObject &lpObj, int source, int target);
int gObjItemRandomOption3Up(LPGameObject &lpObj, int source, int target);
void gObjAbilityReSet(LPGameObject &lpObj);
int gObjTargetGuildWarCheck(LPGameObject &lpObj, CGameObject* lpTargetObj);
void gObjGuildWarEndSend(struct GUILD_INFO_STRUCT* lpGuild1, struct GUILD_INFO_STRUCT* lpGuild2, unsigned char Result1, unsigned char Result2);
void gObjGuildWarEndSend(LPGameObject &lpObj, unsigned char Result1, unsigned char Result2);
void gObjGuildWarEnd(struct GUILD_INFO_STRUCT* lpGuild, struct GUILD_INFO_STRUCT* lpTargetGuild);
int gObjGuildWarProc(struct GUILD_INFO_STRUCT* lpGuild1, struct GUILD_INFO_STRUCT* lpGuild2, int score);
int gObjGuildWarCheck(LPGameObject &lpObj, CGameObject* lpTargetObj);
int gObjGuildWarMasterClose(LPGameObject &lpObj);
int gObjGuildWarItemGive(struct GUILD_INFO_STRUCT* lpWinGuild, struct GUILD_INFO_STRUCT* lpLoseGuild);
int gObjGetPkTime(LPGameObject &lpObj, int& hour, int& min);
int gObjMonsterCall(LPGameObject &lpObj, int MonsterType, int x, int y);
void gObjMonsterCallKill(int aIndex);
bool gObjCheckMoveArea(LPGameObject &lpObj, int X, int Y);
int gObjCheckTeleportArea(LPGameObject &lpObj, unsigned char x, unsigned char y);
int gObjCheckAttackAreaUsedPath(LPGameObject &lpObj, int TarObjIndex);
int gObjCheckattackAreaUsedViewPort(LPGameObject &lpObj, int TarObjIndex);
int gObjCheckAttackArea(LPGameObject &lpObj, int TarObjIndex);
int gUserFindDevilSquareInvitation(int aIndex);
int gUserFindDevilSquareKeyEyes(int aIndex);
void gObjSendUserStatistic(LPGameObject &lpObj, int startLevel, int endLevel);
CGameObject* gObjFind(char* targetcharname);
int gObjFind10EventChip(int aIndex);
int gObjDelete10EventChip(int aIndex);
void gObjSetPosition(LPGameObject &lpObj, int x, int y);
int gObjGetItemCountInEquipment(LPGameObject &lpObj, int itemtype, int itemindex, int itemlevel);
int gObjGetItemCountInIventory(LPGameObject &lpObj, int itemnum);
int gObjGetItemCountInIventory(LPGameObject &lpObj, int itemtype, int itemindex, int itemlevel);
int gObjGetManaItemPos(int aIndex);
void gObjDelteItemCountInInventory(LPGameObject &lpObj, int itemtype, int itemindex, int count);
void gObjGetStatPointState(LPGameObject &lpObj, short& AddPoint, short& MaxAddPoint, short& MinusPoint, short& MaxMinusPoint);
int gObjCheckStatPointUp(int aIndex);
int gObjCheckStatPointDown(int aIndex);
void gObjUseCircle(LPGameObject &lpObj, int pos);
void gObjUsePlusStatFruit(LPGameObject &lpObj, int pos);
void gObjUseMinusStatFruit(LPGameObject &lpObj, int pos);
void CashShopExMinusStatFruit(LPGameObject &lpObj, int pos);
void gObjCalcMaxLifePower(int aIndex);
void gObjDelayLifeCheck(int aIndex);
int gObjDuelCheck(LPGameObject &lpObj);
int gObjDuelCheck(LPGameObject &lpObj, CGameObject* lpTargetObj);
void gObjResetDuel(LPGameObject &lpObj);
void SkillFrustrum(unsigned char bangle, int aIndex);
int SkillTestFrustrum(int x, int y, int aIndex);
int gObjCheckMaxZen(LPGameObject &lpObj, int nAddZen);
void MakeRandomSetItem(int aIndex);
void MakeRandomSetItem(LPGameObject &lpObj, _stGremoryCaseItem & stItem);
void MakeRewardSetItem(LPGameObject &lpObj, BYTE cDropX, BYTE cDropY, int iRewardType, int iMapnumber);
void MakeRewardSetItem(LPGameObject &lpObj, BYTE cDropX, BYTE cDropY, int iRewardType, int iMapnumber, _stGremoryCaseItem & stItem);
void gObjRecall(LPGameObject &lpObj, int mapnumber, int x, int y);
void gObjSetExpPetItem(LPGameObject &lpObj, UINT64 exp);
int gObjGetRandomItemDropLocation(int iMapNumber, BYTE& cX, BYTE& cY, int iRangeX, int iRangeY, int iLoopCount);
int gObjGetRandomFreeLocation(int iMapNumber, BYTE& cX, BYTE& cY, int iRangeX, int iRangeY, int iLoopCount);
int gObjCheckAttackTypeMagic(int iClass, int iSkill);
int gObjGetGuildUnionNumber(LPGameObject &lpObj);
void gObjGetGuildUnionName(LPGameObject &lpObj, char* szUnionName, int iUnionNameLen);
int gObjCheckRival(LPGameObject &lpObj, CGameObject* lpTargetObj);
int gObjGetRelationShip(LPGameObject &lpObj, CGameObject* lpTargetObj);
void gObjNotifyUpdateUnionV1(LPGameObject &lpObj);
void gObjNotifyUpdateUnionV2(LPGameObject &lpObj);
void gObjUnionUpdateProc(int aIndex);
void gObjSetKillCount(LPGameObject &lpObj, int iOption);
void gObjNotifyUseWeaponV1(LPGameObject &lpOwnerObj, CGameObject* lpWeaponObj, int iTargetX, int iTargetY);
void gObjNotifyUseWeaponDamage(LPGameObject &lpWeaponObj, int iTargetX, int iTargetY);
void gObjUseBlessAndSoulPotion(LPGameObject &lpObj, int iItemLevel);
void gObjWeaponDurDownInCastle(LPGameObject &lpObj, CGameObject* lpTargetObj, int iDecValue);
void gObjReady4Relife(LPGameObject &lpObj);
void gObjCheckTimeOutValue(LPGameObject &lpObj, DWORD& rNowTick);
void MsgOutput(LPGameObject &lpObj, char* msg, ...);
void gProcessAutoRecuperation(LPGameObject &lpObj);
void gObjShieldAutoRefill(LPGameObject &lpObj);
int gObjCheckOverlapItemUsingDur(int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjOverlapItemUsingDur(class CItem* lpItem, int iMapNumber, int iItemNumber, int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjCheckOverlapEventItemUsingDur(int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjOverlapEventItemUsingDur(class CItem* lpItem, int iMapNumber, int iItemNumber, int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjCheckSerial0ItemList(class CItem* lpItem);
int gObjCheckInventorySerial0Item(LPGameObject &lpObj);
BOOL gCheckSkillDistance(LPGameObject &lpObj, int aTargetIndex, int iSkillNum);
void gObjSaveChaosBoxItemList(LPGameObject &lpObj);
void gObjQuestMonsterManagement(LPGameObject &lpObj, CGameObject* lpTargetObj);
BYTE gObjOnlyInventory1RectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
BYTE gObjOnlyInventory2RectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
void gObjReqMapSvrAuth(LPGameObject &lpObj);
BOOL gObjGetRandomFreeArea(int iMapNumber, BYTE &cX, BYTE &cY, int iSX, int iSY, int iDX, int iDY, int iLoopCount);
void gObjDeleteBokBlessEtc(LPGameObject &lpObj);
BOOL gObjItemLevelDown(LPGameObject &lpObj, int source, int target);
BOOL gObjItemExcessAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemDoubleUp(LPGameObject &lpObj, int source, int target);
BOOL gObjItemRandomDoubleLevelUp(LPGameObject &lpObj, int source, int target);
BOOL gObjItemKondarAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemRandomOptionNew3Up(LPGameObject &lpObj, int source, int target);
BOOL gObjItemKundumAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemBalanceAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemScienceAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemLuckAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemSpeedAdd(LPGameObject &lpObj, int source, int target);
int gObjCalcHPPercent(double Life, double MaxLife);
bool CheckAuthorityCondition(int AuthorityCode, CGameObject* lpObj);
void GetBundleCount(int count, int div, int& itemcount, int& left);
int gObjGetJewelCountInInventory(LPGameObject &lpObj, BYTE type);
int gGetPartyMaxLevel(int nPartyNumber);
int gGetLowHPMonster(int nZoneIndex, int nIndex, int nDistance);
int gObjGamblingInventoryCheck(LPGameObject &lpObj, int iWidth, int iHeight);
void gObjAddSpecificSkillsForSiege(LPGameObject &lpObj);
void gObjPentagramMixBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, unsigned char set_byte);
void gObjPentagramMixItemSet(LPGameObject &lpObj, int itempos, unsigned char set_byte);
unsigned char gObjPentagramMixBoxInsertItemPos(LPGameObject &lpObj, CItem item, int pos, int source);
unsigned char gObjPentagramMixBoxInsertItem(LPGameObject &lpObj, CItem item);
unsigned char gObjPentagramMixBoxRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjPentagramMixBoxDeleteItem(LPGameObject &lpObj, int itempos);
int gTransPentagramJewelInfoTest(LPGameObject &lpObj, int targetIndex, CItem sourceItem);
int gTransPentagramJewelInfo(LPGameObject &lpObj, BYTE madeItemPos, int targetIndex, CItem sourceItem, int *nJewelCount);
void gObjAutoPartySet(LPGameObject &lpObj /* master */, CGameObject* lpTargetObj /*requestor*/);
BYTE gObjMuunInventoryInsertItemPos(LPGameObject &lpObj, CItem item, int pos);
bool gObjFixMuunInventoryPointer(int aIndex);
void gObjSetMuunInventory1Pointer(CGameObject *lpObj);
void gObjSetMuunInventory2Pointer(CGameObject *lpObj);
BYTE gObjMuunInvenMove(CGameObject *lpObj, int *durSsend, int *durTsend, BYTE source, BYTE target, BYTE *siteminfo);
BYTE gObjChkMuunInventoryEmpty(CGameObject *lpObj);
BYTE gObjMuunInventoryInsertItem(LPGameObject &lpObj, CItem item);
BYTE gObjMuunInventoryInsertItem(LPGameObject &lpObj, CMapItem *item);
BYTE gObjMuunInventoryDeleteItem(LPGameObject &lpObj, int itempos);

/*
void gObjEventInventoryItemSet(LPGameObject &lpObj, int itempos, BYTE set_byte);
void gObjEventInventoryItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
bool gObjFixEventInventoryPointer(int aIndex);
bool gObjEventInventoryDeleteItem(LPGameObject &lpObj, int itempos);
BYTE gObjEventInventoryInsertItemTemp(LPGameObject &lpObj, CMapItem * Item);
BYTE gObjEventInventoryInsertItem(LPGameObject &lpObj, CMapItem * item);
BYTE gObjEventInventoryInsertItem(LPGameObject &lpObj, CItem item);
BYTE gObjEventInvenItemOverlap(LPGameObject &lpObj, int *durSsend, int *durTsend, BYTE source, BYTE target);
BYTE gObjEventInvenMove(LPGameObject &lpObj, int *durSsend, int *durTsend, BYTE source, BYTE target);
BYTE gObjEventInventoryTradeMove(LPGameObject &lpObj, BYTE source, BYTE target);
BYTE gObjTradeEventInventoryMove(LPGameObject &lpObj, BYTE source, BYTE target);
void gObjTempEventInventoryItemBoxSet(BYTE * TempMap, int itempos, int xl, int yl, BYTE set_byte);
BYTE gObjTempEventInventoryRectCheck(LPGameObject &lpObj, BYTE * TempMap, int sx, int sy, int width, int height);
BYTE gObjTempEventInventoryInsertItem(LPGameObject &lpObj, CItem item, BYTE * TempMap);
int CheckEventInventoryEmptySpace(LPGameObject &lpObj, int iItemHeight, int iItemWidth);
int IsEventItem(CItem item);
int IsEventItem(int iType);
BYTE gObjEventInventoryRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
BYTE gObjEventInventoryInsertItemPos(LPGameObject &lpObj, CItem item, int pos, BOOL RequestCheck);
int gObjEventInventorySearchSerialNum(LPGameObject &lpObj, UINT64 serial);
void gObjSetEventInventory1Pointer(LPGameObject &lpObj);
void gObjSetEventInventory2Pointer(LPGameObject &lpObj);
*/

WING_TYPE GetWingType(WORD type, WING_CHECK_FLAG eFlag);
int UseBundleOfBlessJewel(LPGameObject &lpObj, int source, int target);
int IsExceptionJewelOfBlessInchant(LPGameObject &lpObj, int source, int target);
int IsNotApplyJewelToItems(WORD sItemType);
int IsTransformCharacterSkin(int pChange);
int gCountBlessSoulChaosJewel(LPGameObject &lpObj, short & sBlessJewelCount, short & s10BlessJewelCount, short & s20BlessJewelCount, short & s30BlessJewelCount, short & sSoulJewelCount, short & s10SoulJewelCount, short & s20SoulJewelCount, short & s30SoulJewelCount, short & sChaosJewelCount, short & s10ChaosJewelCount, short & s20ChaosJewelCount, short & s30ChaosJewelCount);
int gJewelBuyItemValueTest(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice, short sBlessJewelCount, short s10BlessJewelCount, short s20BlessJewelCount, short s30BlessJewelCount, short sSoulJewelCount, short s10SoulJewelCount, short s20SoulJewelCount, short s30SoulJewelCount, short sChaosJewelCount, short s10ChaosJewelCount, short s20ChaosJewelCount, short s30ChaosJewelCount, short &sBlessJewelNeedCount, short &s10BlessJewelNeedCount, short &s20BlessJewelNeedCount, short &s30BlessJewelNeedCount, short &sSoulJewelNeedCount, short &s10SoulJewelNeedCount, short &s20SoulJewelNeedCount, short &s30SoulJewelNeedCount, short &sChaosJewelNeedCount, short &s10ChaosJewelNeedCount, short &s20ChaosJewelNeedCount, short &s30ChaosJewelNeedCount);
int gJewelInventoryPutTest(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice);
int gJewelInventoryPut(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice, short sBlessJewelNeedCount, short s10BlessJewelNeedCount, short s20BlessJewelNeedCount, short s30BlessJewelNeedCount, short sSoulJewelNeedCount, short s10SoulJewelNeedCount, short s20SoulJewelNeedCount, short s30SoulJewelNeedCount, short sChaosJewelNeedCount, short s10ChaosJewelNeedCount, short s20ChaosJewelNeedCount, short s30ChaosJewelNeedCount);
int CheckInventoryEmptySpaceCount(LPGameObject &lpObj, int iItemHeight, int iItemWidth);
BOOL SummonGoldColossusMonster(LPGameObject &lpObj, int monsterIndex, int nCount, int bIsHelpMon);
BOOL SummonPetEventMonster(LPGameObject &lpObj);
BOOL NewYearSummonMonster(LPGameObject &lpObj, int monsterIndex);
int gObjGetAutoPartyUserCount();
int gObjGetOffTradeUsercount();
void gObjDisconnectOffTraders();
void gObjDisconnectOffLevelers();
void gObjInvenPetDamage(LPGameObject &lpObj, int damage);
BOOL gObjUseInvenPetCheck(LPGameObject &lpObj, CItem *lpItem, int flag);
BOOL IsInvenPet(WORD sIndex);
BOOL IsInvenItem(WORD sIndex);
int gObjCalDistanceTX(LPGameObject &lpObj1, CGameObject* lpObj2);
void Check_SameSerialItem(LPGameObject &lpObj, BYTE bCase, bool & bCheckFail);
bool gObjChaosBoxPutItemTest(LPGameObject &lpObj, CItem Item, BYTE btCount);
BYTE gObjChaosBoxInsertItemTemp(LPGameObject &lpObj, CItem * Item);
BOOL gObjUnicornSprite(LPGameObject &lpObj);
void gObjUseRecoveryPotion(LPGameObject &lpObj, int pos, double value);
void gObjMuBotPayForUse(LPGameObject &lpObj);
void gObjMuBotProc(LPGameObject &lpObj);

#endif
