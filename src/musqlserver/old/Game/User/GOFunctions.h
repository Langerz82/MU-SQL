#ifndef _MU_GOFUNCTIONS_H_
#define _MU_GOFUNCTIONS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "StdAfx.h"

void gObjSkillUseProcTime500(LPGameObject &lpObj);
void MonsterAndMsgProc();
void MoveMonsterProc();
void gObjSetState();
void gObjInit(); // constructor ?
void gObjEnd(); // destructor ?
void gObjClearViewportOfMine(LPGameObject &lpObj);
void gObjClearViewport(LPGameObject &lpObj);
void gObjCloseSet(LPGameObject &lpObj, int Flag);
void gObjCharTradeClear(LPGameObject &lpObj);
void gObjCharZeroSet(LPGameObject &lpObj);
int gObjGetSocket(SOCKET socket);
int gObjGetHWIDUseCount(LPSTR HWID);
void gObjSetTradeOption(LPGameObject &lpObj, int option);
bool IsDuelEnable(LPGameObject &lpObj);
bool IsOnDuel(LPGameObject &lpObj1, LPGameObject &lpObj2);
void gObjSetDuelOption(LPGameObject &lpObj, int option);
int GetMapMoveLevel(LPGameObject &lpObj, int mapnumber, int max_over);
void DbItemSetInByte(LPGameObject &lpObj, struct SDHP_DBCHAR_INFORESULT* lpMsg, bool* bAllItemExist);
void gObjSetBP(LPGameObject &lpObj);
bool gObjSetCharacter(LPBYTE lpdata, int aIndex);
int gObjCanItemTouch(LPGameObject &lpObj, int type);
void gObjMagicTextSave(LPGameObject &lpObj);
void ItemIsBufExOption(LPBYTE buf, CItem* lpItem);
void gObjStatTextSave(LPGameObject &lpObj);
void gObjItemTextSave(LPGameObject &lpObj);
void gObjWarehouseTextSave(LPGameObject &lpObj);
void gObjAuthorityCodeSet(LPGameObject &lpObj);
int gObjSetPosMonster(LPGameObject &lpObj, int PosTableNum);
int gObjSetMonster(LPGameObject &lpObj, int MonsterClass);
int gObjGetSocket(SOCKET socket);
int GetMapMoveLevel(LPGameObject &lpObj, int mapnumber, int max_over);
short gObjAddSearch(SOCKET aSocket, char* ip);
short gObjAdd(SOCKET aSocket, char* ip, int aIndex);
short gObjMonsterRecall(int iMapNumber);
short gObjAddMonster(int iMapNumber);
short gObjAddCallMon();
void gObjUserKill(LPGameObject &lpObj);
void gObjAllLogOut();
void gObjAllDisconnect();
void gObjTradeSave(LPGameObject &lpObj, int index);
void gObjBillRequest(LPGameObject &lpObj);
short gObjMemFree(LPGameObject &lpObj);
int gObjGameClose(LPGameObject &lpObj);
short gObjDel(LPGameObject &lpObj);
short gObjSometimeClose(LPGameObject &lpObj);
int gObjIsGamePlaing(LPGameObject &lpObj);
int gObjIsConnectedGP(LPGameObject &lpObj, char* CharName);
int gObjIsConnectedGP(LPGameObject &lpObj);
int gObjIsConnected(LPGameObject &lpObj, int dbnumber);
int gObjIsConnected(LPGameObject &lpObj);
bool gObjIsAccountValid(LPGameObject &lpObj, char* account);
int gObjIsConnected(LPGameObject &lpObj);
int gObjIsConnectedEx(LPGameObject &lpObj);
int gObjIsAccontConnect(LPGameObject &lpObj, char* accountid);
int gObjPasswordCheck(LPGameObject &lpObj, char* szInPassword);
int gObjCheckXYMapTile(LPGameObject &lpObj, int iDbgName);
int gObjSetAccountLogin(LPGameObject &lpObj, char* szId, int aUserNumber, int aDBNumber, char* Password);
int gObjGetUserNumber(LPGameObject &lpObj);
int gObjGetNumber(LPGameObject &lpObj, int& UN, int& DBN);
LPSTR gObjGetAccountId(LPGameObject &lpObj);
int gObjGetIndex(char* szId);
int gObjUserIdConnectCheck(char* szId, int index);
unsigned char GetPathPacketDirPos(int px, int py);
int gObjCalDistance(LPGameObject &lpObj1, LPGameObject &lpObj2);
int gObjPositionCheck(LPGameObject &lpObj);
int gObjCheckTileArea(LPGameObject &lpObj, int x, int y, int dis);
int ExtentCheck(int x, int y, int w, int h);
BOOL CheckOutOfInventory(LPGameObject &lpObj, int sy, int height);	//-> 1.01.00
BOOL InventoryExtentCheck(int x, int y, int w, int h);		//-> 1.01.00
BOOL CheckOutOfWarehouse(LPGameObject &lpObj, int sy, int height);	//-> 1.01.00
BOOL WarehouseExtentCheck(int x, int y, int w, int h);		//-> 1.01.00
void gObjSetInventory1Pointer(LPGameObject &lpObj);
void gObjSetInventory2Pointer(LPGameObject &lpObj);
void gObjAddMsgSend(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode);
void gObjAddMsgSendDelay(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode);
void gObjAddMsgSendDelayInSpecificQPos(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode, int iQPosition);
void gObjAddAttackProcMsgSendDelay(LPGameObject &lpObj, int aMsgCode, int aIndex, int delay, int SubCode, int SubCode2);
void gObjMsgProc(LPGameObject &lpObj);
void gObjStateProc(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode);
void gObjStateAttackProc(LPGameObject &lpObj, int aMsgCode, int aIndex, int SubCode, int SubCode2);
int gObjBackSpring(LPGameObject &lpObj, LPGameObject &lpTargetObj);
int BackSpringCheck(int& x, int& y, int& dir, BYTE map);
int gObjBackSpring2(LPGameObject &lpObj, LPGameObject &lpTargetObj, int count);
bool gObjLevelUp(LPGameObject &lpObj, UINT64 addexp, int iMonsterType, const char * szEventType);
int gObjLevelUpPointAdd(unsigned char type, LPGameObject &lpObj, int aIndex);
void gObjGiveItemSearch(LPGameObject &lpObj, int maxlevel);
void gObjGiveItemWarehouseSearch(LPGameObject &lpObj, int maxlevel);
int gObjGuildMasterCapacityTest(LPGameObject &lpObj);
void gObjNextExpCal(LPGameObject &lpObj);
int retResistance(LPGameObject &lpObj, int Resistance_Type);
int retCalcSkillResistance(LPGameObject &lpTargetObj, int isDouble);
int gObjAttackQ(LPGameObject &lpObj);
void gObjPlayerKiller(LPGameObject &lpObj, LPGameObject &lpTargetObj, int MSBDamage);
void gObjUserDie(LPGameObject &lpObj, LPGameObject &lpTargetObj);
void gObjInterfaceTimeCheck(LPGameObject &lpObj);
void gObjPkDownTimeCheck(LPGameObject &lpObj, int TargetLevel);
int gObjAngelSprite(LPGameObject &lpObj);
int gObjDemonSprite(LPGameObject &lpObj);
int gObjSatanSprite(LPGameObject &lpObj);
int gObjSafeGuardSprite(LPGameObject &lpObj);
int gObjFindInventoryEquipment(LPGameObject &lpObj);
int gObjSetInventoryEquipment(LPGameObject &lpObj, BYTE btPos);
int gObjInventoryEquipment(LPGameObject &lpObj);
int gObjWingSprite(LPGameObject &lpObj);
int gObjUniriaSprite(LPGameObject &lpObj);
void gObjSpriteDamage(LPGameObject &lpObj, int damage);
void gObjSecondDurDown(LPGameObject &lpObj);
void gObjChangeDurProc(LPGameObject &lpObj);
void gObjWingDurProc(LPGameObject &lpObj);
void gObjPenaltyDurDown(LPGameObject &lpObj, LPGameObject &lpTargetObj);
void gObjWeaponDurDown(LPGameObject &lpObj, LPGameObject &lpTargetObj, int type);
void gObjArmorRandomDurDown(LPGameObject &lpObj, LPGameObject &lpAttackObj);
bool gObjIsSelfDefense(LPGameObject &lpObj, int aTargetIndex);
void gObjCheckSelfDefense(LPGameObject &lpObj, int aTargetIndex);
void gObjTimeCheckSelfDefense(LPGameObject &lpObj);
int gObjAttack(LPGameObject &lpObj, LPGameObject &lpTargetObj, class CMagicInf* lpMagic, int magicsend, BYTE MSBFlag, int AttackDamage, BOOL bCombo, BYTE RFAttack, BYTE byReflect, BYTE byPentagramAttack = TRUE);
void gObjMonsterExpDivision(LPGameObject &lpMonObj, LPGameObject &lpObj, int AttackDamage, int MSBFlag);
void gObjMonsterExpDivisionRenewal(LPGameObject &lpMonObj, LPGameObject &lpObj, int AttackDamage, int MSBFlag);
UINT64 gObjMonsterExpSingle(LPGameObject &lpObj, LPGameObject &lpTargetObj, int dmg, int tot_dmg, bool& bSendExp, UINT64& nDropZen);
UINT64 gObjMonsterExpSingleRenewal(LPGameObject &lpObj, LPGameObject &lpTargetObj, int dmg, int tot_dmg, bool &bSendExp);
void gObjExpParty(LPGameObject &lpObj, LPGameObject &lpTargetObj, int AttackDamage, int MSBFlag);
UINT64 gObjExpPartyRenewal(int nPartyNumber, int nLastAttackUserIndex, LPGameObject &lpTargetObj, int AttackDamage, int nTotalDamage, int MSBFlag);
void gObjMonsterDieLifePlus(LPGameObject &lpObj, LPGameObject &lpTartObj);
void gObjLifeCheck(LPGameObject &lpTargetObj, LPGameObject &lpObj, int AttackDamage, int DamageSendType, int MSBFlag, int MSBDamage, unsigned short Skill, int iShieldDamage, int iElementalDamage);
int gObjInventoryTrans(LPGameObject &lpObj);
int gObjInventoryCommit(LPGameObject &lpObj);
int gObjInventoryRollback(LPGameObject &lpObj);
void gObjInventoryItemSet(LPGameObject &lpObj, int itempos, BYTE set_byte);
void gObjInventoryItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
bool gObjFixInventoryPointer(LPGameObject &lpObj);
BYTE gObjInventoryDeleteItem(LPGameObject &lpObj, int itempos);
BYTE gObjWarehouseDeleteItem(LPGameObject &lpObj, int itempos);
BYTE gObjChaosBoxDeleteItem(LPGameObject &lpObj, int itempos);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int iSerial, int iDur);
DWORD gGetItemNumber();
void gPlusItemNumber();
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int iSerial, int iDur);
unsigned char gObjOnlyInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level);
int gObjSearchItem(LPGameObject &lpObj, int item_type, int add_dur, int nLevel);
int gObjSearchItemMinus(LPGameObject &lpObj, int pos, int m_dur);
unsigned char gObjShopBuyInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjShopBuyMuunInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjShopBuyEventInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjInventoryInsertItemTemp(LPGameObject &lpObj, class CMapItem* Item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, class CMapItem* item);
unsigned char gObjInventoryInsertItem(LPGameObject &lpObj, class CItem item);
unsigned char gObjMonsterInventoryInsertItem(LPGameObject &lpObj, int type, int index, int level, int op1, int op2, int op3);
unsigned char gObjInventoryRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjOnlyInventoryRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
int CheckInventoryEmptySpace(LPGameObject &lpObj, int iItemHeight, int iItemWidth);
int gObjIsItemPut(LPGameObject &lpObj, class CItem* lpItem, int pos);
unsigned char gObjWerehouseRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjMapRectCheck(LPBYTE lpMapBuf, int sx, int sy, int ex, int ey, int width, int height);
void gObjWarehouseItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
void gObjWarehouseItemSet(LPGameObject &lpObj, int itempos, BYTE set_byte);
void gObjChaosItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
void gObjChaosItemSet(LPGameObject &lpObj, int itempos, BYTE set_byte);
unsigned char gObjChaosBoxInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int source);
unsigned char gObjWarehouseInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int source);
unsigned char gObjInventoryInsertItemPos(LPGameObject &lpObj, class CItem item, int pos, int RequestCheck);
int gObjInventorySearchSerialNumber(LPGameObject &lpObj, UINT64 serial);
int gObjWarehouseSearchSerialNumber(LPGameObject &lpObj, UINT64 sirial);
unsigned char gObjInventoryMoveItem(LPGameObject &lpObj, BYTE source, BYTE target, int& durSsend, int& durTsend, BYTE sFlag, BYTE tFlag, LPBYTE siteminfo);
unsigned char gObjTradeRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
int gObjTradeItemBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
unsigned char gObjTradeInventoryMove(LPGameObject &lpObj, BYTE source, BYTE target);
unsigned char gObjInventoryTradeMove(LPGameObject &lpObj, BYTE source, BYTE target);
unsigned char gObjTradeTradeMove(LPGameObject &lpObj, BYTE source, BYTE target);
void gObjTradeCancel(LPGameObject &lpObj);
void gObjTempInventoryItemBoxSet(LPBYTE TempMap, int itempos, int xl, int yl, BYTE set_byte);
unsigned char gObjTempInventoryRectCheck(LPGameObject &lpObj, LPBYTE TempMap, int sx, int sy, int width, int height);
unsigned char gObjTempInventoryInsertItem(LPGameObject &lpObj, class CItem item, LPBYTE TempMap);
int TradeItemInventoryPutTest(LPGameObject &lpObj);
int TradeitemInventoryPut(LPGameObject &lpObj);
void gObjTradeOkButton(LPGameObject &lpObj);
unsigned char LevelSmallConvert(int level);
unsigned char LevelSmallConvert(LPGameObject &lpObj, int inventoryindex);
void gObjAttackDamageCalc(LPGameObject &lpObj);
void gObjMakePreviewCharSet(LPGameObject &lpObj);
void gObjViewportPaint(HWND hWnd);
void InitFrustrum();
void InitFrustrumEx(); // 1.01.10B GS KOR, changed values
void CreateFrustrum(int x, int y, int aIndex);
bool TestFrustrum2(int x, int y, int aIndex);
int gObjCheckViewport(LPGameObject &lpObj, int x, int y);
void gObjViewportClose(LPGameObject &lpObj);
void gObjViewportListCreate(short aIndex);
int ViewportAdd(LPGameObject &lpObj, int aAddIndex, int aType);
int ViewportAdd2(LPGameObject &lpObj, int aAddIndex, int aType);
void ViewportDel(short aIndex, int aDelIndex);
void Viewport2Del(short aIndex, int aDelIndex);
void gObjViewportAllDel(short aIndex);
void gObjViewportListDestroy(short aIndex);;
void gObjStateSetCreate(LPGameObject &lpObj);
void gObjSecondProc();
void gObjManaPotionFill(LPGameObject &lpObj);
void gObjRestPotionFill(LPGameObject &lpObj);
void gObjUseDrink(LPGameObject &lpObj, int level);
void gObjViewportListProtocolDestroy(LPGameObject &lpObj);
void gObjViewportListProtocolCreate(LPGameObject &lpObj);
void gObjViewportListProtocol(short aIndex);
void gObjTeleportMagicUse(LPGameObject &lpObj, BYTE x, BYTE y);
int gObjMoveGate(LPGameObject &lpObj, int gt);
void gObjTeleport(LPGameObject &lpObj, int map, int x, int y);
void gObjMoveDataLoadingOK(LPGameObject &lpObj);
class CMagicInf* gObjGetMagic(LPGameObject &lpObj, int mIndex);
class CMagicInf* gObjGetMagicSearch(LPGameObject &lpObj, unsigned short skillnumber);
int gObjMagicManaUse(LPGameObject &lpObj, class CMagicInf* lpMagic);
int gObjMagicBPUse(LPGameObject &lpObj, class CMagicInf* lpMagic);
void gObjMagicAddEnergyCheckOnOff(int flag);
int gObjMagicAdd(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMagicDel(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMagicAdd(LPGameObject &lpObj, unsigned short Type, unsigned short Index, BYTE Level, unsigned short& SkillNumber);
int gObjWeaponMagicAdd(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMonsterMagicAdd(LPGameObject &lpObj, unsigned short aSkill, BYTE Level);
int gObjMagicEnergyCheck(LPGameObject &lpObj, unsigned short aSkill);
int gObjSpecialItemLevelUp(LPGameObject &lpObj, int source, int target);
int gObjSpecialItemRepair(LPGameObject &lpObj, int source, int target);
int gObjItemLevelUp(LPGameObject &lpObj, int source, int target);
int gObjItemRandomLevelUp(LPGameObject &lpObj, int source, int target);
int gObjItemRandomOption3Up(LPGameObject &lpObj, int source, int target);
void gObjAbilityReSet(LPGameObject &lpObj);
int gObjTargetGuildWarCheck(LPGameObject &lpObj, LPGameObject &lpTargetObj);
void gObjGuildWarEndSend(struct GUILD_INFO_STRUCT* lpGuild1, struct GUILD_INFO_STRUCT* lpGuild2, BYTE Result1, BYTE Result2);
void gObjGuildWarEndSend(LPGameObject &lpObj, BYTE Result1, BYTE Result2);
void gObjGuildWarEnd(struct GUILD_INFO_STRUCT* lpGuild, struct GUILD_INFO_STRUCT* lpTargetGuild);
int gObjGuildWarProc(struct GUILD_INFO_STRUCT* lpGuild1, struct GUILD_INFO_STRUCT* lpGuild2, int score);
int gObjGuildWarCheck(LPGameObject &lpObj, LPGameObject &lpTargetObj);
int gObjGuildWarMasterClose(LPGameObject &lpObj);
int gObjGuildWarItemGive(struct GUILD_INFO_STRUCT* lpWinGuild, struct GUILD_INFO_STRUCT* lpLoseGuild);
int gObjGetPkTime(LPGameObject &lpObj, int& hour, int& min);
int gObjMonsterCall(LPGameObject &lpObj, int MonsterType, int x, int y);
void gObjMonsterCallKill(LPGameObject &lpObj);
bool gObjCheckMoveArea(LPGameObject &lpObj, int X, int Y);
int gObjCheckTeleportArea(LPGameObject &lpObj, BYTE x, BYTE y);
int gObjCheckAttackAreaUsedPath(LPGameObject &lpObj, int TarObjIndex);
int gObjCheckattackAreaUsedViewPort(LPGameObject &lpObj, int TarObjIndex);
int gObjCheckAttackArea(LPGameObject &lpObj, int TarObjIndex);
int gUserFindDevilSquareInvitation(LPGameObject &lpObj);
int gUserFindDevilSquareKeyEyes(LPGameObject &lpObj);
void gObjSendUserStatistic(LPGameObject &lpObj, int startLevel, int endLevel);
CGameObject* gObjFind(LPTSTR targetcharname);
int gObjFind10EventChip(LPGameObject &lpObj);
int gObjDelete10EventChip(LPGameObject &lpObj);
void gObjSetPosition(LPGameObject &lpObj, int x, int y);
int gObjGetItemCountInEquipment(LPGameObject &lpObj, int itemtype, int itemindex, int itemlevel);
int gObjGetItemCountInIventory(LPGameObject &lpObj, int itemnum);
int gObjGetItemCountInIventory(LPGameObject &lpObj, int itemtype, int itemindex, int itemlevel);
int gObjGetManaItemPos(LPGameObject &lpObj);
void gObjDelteItemCountInInventory(LPGameObject &lpObj, int itemtype, int itemindex, int count);
void gObjGetStatPointState(LPGameObject &lpObj, short& AddPoint, short& MaxAddPoint, short& MinusPoint, short& MaxMinusPoint);
int gObjCheckStatPointUp(LPGameObject &lpObj);
int gObjCheckStatPointDown(LPGameObject &lpObj);
void gObjUseCircle(LPGameObject &lpObj, int pos);
void gObjUsePlusStatFruit(LPGameObject &lpObj, int pos);
void gObjUseMinusStatFruit(LPGameObject &lpObj, int pos);
void CashShopExMinusStatFruit(LPGameObject &lpObj, int pos);
void gObjCalcMaxLifePower(LPGameObject &lpObj);
void gObjDelayLifeCheck(LPGameObject &lpObj);
int gObjDuelCheck(LPGameObject &lpObj);
int gObjDuelCheck(LPGameObject &lpObj, LPGameObject &lpTargetObj);
void gObjResetDuel(LPGameObject &lpObj);
void SkillFrustrum(unsigned char bangle, int aIndex);
int SkillTestFrustrum(int x, int y, int aIndex);
int gObjCheckMaxZen(LPGameObject &lpObj, int nAddZen);
void MakeRandomSetItem(LPGameObject &lpObj);
void MakeRandomSetItem(LPGameObject &lpObj, _stGremoryCaseItem & stItem);
void MakeRewardSetItem(LPGameObject &lpObj, BYTE cDropX, BYTE cDropY, int iRewardType, int iMapnumber);
void MakeRewardSetItem(LPGameObject &lpObj, BYTE cDropX, BYTE cDropY, int iRewardType, int iMapnumber, _stGremoryCaseItem & stItem);
void gObjRecall(LPGameObject &lpObj, int mapnumber, int x, int y);
void gObjSetExpPetItem(LPGameObject &lpObj, UINT64 exp);
int gObjGetRandomItemDropLocation(int iMapNumber, BYTE& cX, BYTE& cY, int iRangeX, int iRangeY, int iLoopCount);
int gObjGetRandomFreeLocation(int iMapNumber, BYTE& cX, BYTE& cY, int iRangeX, int iRangeY, int iLoopCount);
int gObjCheckAttackTypeMagic(int iClass, int iSkill);
int gObjGetGuildUnionNumber(LPGameObject &lpObj);
void gObjGetGuildUnionName(LPGameObject &lpObj, char* szUnionName, int iUnionNameLen);
int gObjCheckRival(LPGameObject &lpObj, LPGameObject &lpTargetObj);
int gObjGetRelationShip(LPGameObject &lpObj, LPGameObject &lpTargetObj);
void gObjNotifyUpdateUnionV1(LPGameObject &lpObj);
void gObjNotifyUpdateUnionV2(LPGameObject &lpObj);
void gObjUnionUpdateProc(LPGameObject &lpObj);
void gObjSetKillCount(LPGameObject &lpObj, int iOption);
void gObjNotifyUseWeaponV1(LPGameObject &lpOwnerObj, LPGameObject &lpWeaponObj, int iTargetX, int iTargetY);
void gObjNotifyUseWeaponDamage(LPGameObject &lpWeaponObj, int iTargetX, int iTargetY);
void gObjUseBlessAndSoulPotion(LPGameObject &lpObj, int iItemLevel);
void gObjWeaponDurDownInCastle(LPGameObject &lpObj, LPGameObject &lpTargetObj, int iDecValue);
void gObjReady4Relife(LPGameObject &lpObj);
void gObjCheckTimeOutValue(LPGameObject &lpObj, DWORD& rNowTick);
void MsgOutput(LPGameObject &lpObj, char* msg, ...);
void gProcessAutoRecuperation(LPGameObject &lpObj);
void gObjShieldAutoRefill(LPGameObject &lpObj);
int gObjCheckOverlapItemUsingDur(int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjOverlapItemUsingDur(class CItem* lpItem, int iMapNumber, int iItemNumber, int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjCheckOverlapEventItemUsingDur(int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjOverlapEventItemUsingDur(class CItem* lpItem, int iMapNumber, int iItemNumber, int iUserIndex, int iMaxOverlapped, int iItemType, int iItemLevel);
int gObjCheckSerial0ItemList(class CItem* lpItem);
int gObjCheckInventorySerial0Item(LPGameObject &lpObj);
BOOL gCheckSkillDistance(LPGameObject &lpObj, int aTargetIndex, int iSkillNum);
void gObjSaveChaosBoxItemList(LPGameObject &lpObj);
void gObjQuestMonsterManagement(LPGameObject &lpObj, LPGameObject &lpTargetObj);
BYTE gObjOnlyInventory1RectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
BYTE gObjOnlyInventory2RectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
void gObjReqMapSvrAuth(LPGameObject &lpObj);
BOOL gObjGetRandomFreeArea(int iMapNumber, BYTE &cX, BYTE &cY, int iSX, int iSY, int iDX, int iDY, int iLoopCount);
void gObjDeleteBokBlessEtc(LPGameObject &lpObj);
BOOL gObjItemLevelDown(LPGameObject &lpObj, int source, int target);
BOOL gObjItemExcessAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemDoubleUp(LPGameObject &lpObj, int source, int target);
BOOL gObjItemRandomDoubleLevelUp(LPGameObject &lpObj, int source, int target);
BOOL gObjItemKondarAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemRandomOptionNew3Up(LPGameObject &lpObj, int source, int target);
BOOL gObjItemKundumAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemBalanceAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemScienceAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemLuckAdd(LPGameObject &lpObj, int source, int target);
BOOL gObjItemSpeedAdd(LPGameObject &lpObj, int source, int target);
int gObjCalcHPPercent(double Life, double MaxLife);
bool CheckAuthorityCondition(int AuthorityCode, LPGameObject &lpObj);
void GetBundleCount(int count, int div, int& itemcount, int& left);
int gObjGetJewelCountInInventory(LPGameObject &lpObj, BYTE type);
int gGetPartyMaxLevel(int nPartyNumber);
int gGetLowHPMonster(int nZoneIndex, int nIndex, int nDistance);
int gObjGamblingInventoryCheck(LPGameObject &lpObj, int iWidth, int iHeight);
void gObjAddSpecificSkillsForSiege(LPGameObject &lpObj);
void gObjPentagramMixBoxSet(LPGameObject &lpObj, int itempos, int xl, int yl, BYTE set_byte);
void gObjPentagramMixItemSet(LPGameObject &lpObj, int itempos, BYTE set_byte);
unsigned char gObjPentagramMixBoxInsertItemPos(LPGameObject &lpObj, CItem item, int pos, int source);
unsigned char gObjPentagramMixBoxInsertItem(LPGameObject &lpObj, CItem item);
unsigned char gObjPentagramMixBoxRectCheck(LPGameObject &lpObj, int sx, int sy, int width, int height);
unsigned char gObjPentagramMixBoxDeleteItem(LPGameObject &lpObj, int itempos);
int gTransPentagramJewelInfoTest(LPGameObject &lpObj, int targetIndex, CItem sourceItem);
int gTransPentagramJewelInfo(LPGameObject &lpObj, BYTE madeItemPos, int targetIndex, CItem sourceItem, int *nJewelCount);
void gObjAutoPartySet(LPGameObject &lpObj /* master */, LPGameObject &lpTargetObj /*requestor*/);
BYTE gObjMuunInventoryInsertItemPos(LPGameObject &lpObj, CItem item, int pos);
bool gObjFixMuunInventoryPointer(LPGameObject &lpObj);
void gObjSetMuunInventory1Pointer(CGameObject *lpObj);
void gObjSetMuunInventory2Pointer(CGameObject *lpObj);
BYTE gObjMuunInvenMove(CGameObject *lpObj, int *durSsend, int *durTsend, BYTE source, BYTE target, BYTE *siteminfo);
BYTE gObjChkMuunInventoryEmpty(CGameObject *lpObj);
BYTE gObjMuunInventoryInsertItem(LPGameObject &lpObj, CItem item);
BYTE gObjMuunInventoryInsertItem(LPGameObject &lpObj, CMapItem *item);
BYTE gObjMuunInventoryDeleteItem(LPGameObject &lpObj, int itempos);

WING_TYPE GetWingType(WORD type, WING_CHECK_FLAG eFlag);
int UseBundleOfBlessJewel(LPGameObject &lpObj, int source, int target);
int IsExceptionJewelOfBlessInchant(LPGameObject &lpObj, int source, int target);
int IsNotApplyJewelToItems(WORD sItemType);
int IsTransformCharacterSkin(int pChange);
int gCountBlessSoulChaosJewel(LPGameObject &lpObj, short & sBlessJewelCount, short & s10BlessJewelCount, short & s20BlessJewelCount, short & s30BlessJewelCount, short & sSoulJewelCount, short & s10SoulJewelCount, short & s20SoulJewelCount, short & s30SoulJewelCount, short & sChaosJewelCount, short & s10ChaosJewelCount, short & s20ChaosJewelCount, short & s30ChaosJewelCount);
int gJewelBuyItemValueTest(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice, short sBlessJewelCount, short s10BlessJewelCount, short s20BlessJewelCount, short s30BlessJewelCount, short sSoulJewelCount, short s10SoulJewelCount, short s20SoulJewelCount, short s30SoulJewelCount, short sChaosJewelCount, short s10ChaosJewelCount, short s20ChaosJewelCount, short s30ChaosJewelCount, short &sBlessJewelNeedCount, short &s10BlessJewelNeedCount, short &s20BlessJewelNeedCount, short &s30BlessJewelNeedCount, short &sSoulJewelNeedCount, short &s10SoulJewelNeedCount, short &s20SoulJewelNeedCount, short &s30SoulJewelNeedCount, short &sChaosJewelNeedCount, short &s10ChaosJewelNeedCount, short &s20ChaosJewelNeedCount, short &s30ChaosJewelNeedCount);
int gJewelInventoryPutTest(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice);
int gJewelInventoryPut(int aBuyerIndex, int aSellerIndex, short sBlessJewelPrice, short sSoulJewelPrice, short sChaosJewelPrice, short sBlessJewelNeedCount, short s10BlessJewelNeedCount, short s20BlessJewelNeedCount, short s30BlessJewelNeedCount, short sSoulJewelNeedCount, short s10SoulJewelNeedCount, short s20SoulJewelNeedCount, short s30SoulJewelNeedCount, short sChaosJewelNeedCount, short s10ChaosJewelNeedCount, short s20ChaosJewelNeedCount, short s30ChaosJewelNeedCount);
int CheckInventoryEmptySpaceCount(LPGameObject &lpObj, int iItemHeight, int iItemWidth);
BOOL SummonGoldColossusMonster(LPGameObject &lpObj, int monsterIndex, int nCount, int bIsHelpMon);
BOOL SummonPetEventMonster(LPGameObject &lpObj);
BOOL NewYearSummonMonster(LPGameObject &lpObj, int monsterIndex);
int gObjGetAutoPartyUserCount();
int gObjGetOffTradeUsercount();
void gObjDisconnectOffTraders();
void gObjDisconnectOffLevelers();
void gObjInvenPetDamage(LPGameObject &lpObj, int damage);
BOOL gObjUseInvenPetCheck(LPGameObject &lpObj, CItem *lpItem, int flag);
BOOL IsInvenPet(WORD sIndex);
BOOL IsInvenItem(WORD sIndex);
int gObjCalDistanceTX(LPGameObject &lpObj1, LPGameObject &lpObj2);
void Check_SameSerialItem(LPGameObject &lpObj, BYTE bCase, bool & bCheckFail);
bool gObjChaosBoxPutItemTest(LPGameObject &lpObj, CItem Item, BYTE btCount);
BYTE gObjChaosBoxInsertItemTemp(LPGameObject &lpObj, CItem * Item);
BOOL gObjUnicornSprite(LPGameObject &lpObj);
void gObjUseRecoveryPotion(LPGameObject &lpObj, int pos, double value);
void gObjMuBotPayForUse(LPGameObject &lpObj);
void gObjMuBotProc(LPGameObject &lpObj);

#endif
